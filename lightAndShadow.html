<!DOCTYPE html>
<html lang="en">

<html>
<head>
    <meta charset="UTF-8">
    <title>光与影</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            /* 隐藏body窗口区域滚动条 */
        }
    </style>
    <script src="https://cdn.bootcdn.net/ajax/libs/three.js/r122/three.min.js"></script>
    <script src="JS/three/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
</head>
<body>
    <!-- <div>
        <h3>光的颜色符合物理学</h3>
        <p>红色的物体不能反射蓝色的光, 灰色的物体却能反射蓝色的光。</p>

        <p>1.自然光符合物理学, 不好计算。</p>
        <p>2.自然光源没有特别的来源方向，不会产生阴影。</p>      
        <p>3.不能将其作为场景中唯一的光源, 但可以配合其他光源, 起到弱化阴影或给场景添加一些额外的颜色的作用。</p>
        <p>4.自然光不需要指定位置它会应用到全局。</p>
    </div> -->
    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.z = 40;
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000);
        orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
        document.body.appendChild(renderer.domElement);


        /**
         * 创建场景参数，方块，墙体，地板
         */
        const cube = initCube({
            color: 'red',
            len: [3, 1, 3],
            position: [0, 2, 0]
        })
        const wall = initCube({
            color: 'gray',
            len: [0.1, 10, 20],
            position: [-10.1, 5, 0]
        })
        const land = initCube({
            color: 'gray',
            len: [20, 0.1, 20],
            position: [0, 0, 0]
        })
        scene.add(cube);
        scene.add(wall);
        scene.add(land);

        /**
         * 点光源设置，自然光一般不设置，原因参考上面
         * intensity光强, 想要成为最亮的星。
         * distance光源照射的距离, 默认值为0也就是无限。
         * visible布尔值, 是否打开光源。
         * decay衰减值, 越大衰减速度越快。
         * 
         * 点光源照亮四面八方，生成阴影所需要计算量过大，不建议开启阴影
         */
        // const light = new THREE.PointLight('white');
        // light.intensity = 3;
        // light.distance = 30;
        // light.position.set(5, 8, -5);
        // scene.add(light)

        /**
         * 影子生成的定义和聚光灯
         * 想要生成影子可不是那么简单的, 因为可想而知在数学方面影子的计算量必然很大的
         * 在three.js中物体是否可以显示影子是需要单独定义的。
         * a物体想在b物体上产生阴影，那么ab上都要设置阴影的属性
         */

        // 先设置聚光灯, 聚光灯为有方向的灯，可以指定照谁，并可以产生阴影,聚光灯产生的是锥形光
        // let light = new THREE.SpotLight("#ffffff", 1);
        // light.position.set(8, 8, 0);
        // light.intensity = 2;
        // light.penumbra = 0.05;
        // light.angle = Math.PI / 5;
        // light.target = cube // target指定照谁, target必须是一个THREE.Object3D对象, 所以我们经常会先创建一个Object3D对象, 让它不可见然后光源就可以通过照射它, 从而实现任意方向。
        // scene.add(light);


        /**
         * 平行光
         * 经常被举例子的就是太阳光, 实际上太阳光也不是平行的, 只是距离太远了几乎可以算是平行。
         * 这个光源与其他的不同的点是, 他它所照耀的区域接收到的光强是一样的。
         */
        const light = new THREE.DirectionalLight("#ffffff");
        light.intensity = 1.5;
        light.position.set(8, 8, 0);
        light.castShadow = true;
        light.target = cube
        light.shadow.camera.near = 5; //产生阴影的最近距离
        light.shadow.camera.far = 50; //产生阴影的最远距离
        light.shadow.camera.left = -3; //产生阴影距离位置的最左边位置
        light.shadow.camera.right = 3; //最右边
        light.shadow.camera.top = 3; //最上边
        light.shadow.camera.bottom = -3; //最下面
        scene.add(light);

        
        /**
         * 添加聚光灯辅助线，调试用
        */
        const helper = new THREE.CameraHelper(light.shadow.camera);
        scene.add(helper);
        renderer.shadowMap.enabled = true; // 第一步，渲染器支持,shadowMap.enabled设置成开启状态

        light.castShadow = true; // 第二步，为光设定可生成阴影属性

        cube.castShadow = true; // 第三步，给物体添加可生成阴影属性
        wall.castShadow = true;
        land.castShadow = true;
        
        cube.receiveShadow = true; // 第四步，为物体设置可接收阴影属性
        wall.receiveShadow = true;
        land.receiveShadow = true;

        var animate = function () {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        };
        animate();

        function initCube(options) {
            const geometry = new THREE.BoxGeometry(...options.len);
            const material = new THREE.MeshLambertMaterial({ color: options.color }); // 此处用MeshLambertMaterial，材质高级属性，这个属性表面需要光照
            const cube = new THREE.Mesh(geometry, material);
            cube.position.add(new THREE.Vector3(...options.position));
            scene.add(new THREE.BoxHelper(cube, 0x00000)); // 设置立方体边框，并且放入场景中，cube后是边框颜色
            return cube
        }
    </script>
</body>

</html>